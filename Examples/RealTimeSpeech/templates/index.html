<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <title>Real Time Audio Play Test</title>

    <style>
    </style>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"
        integrity="sha384-/KNQL8Nu5gCHLqwqfQjA689Hhoqgi2S84SNUxC3roTe4EhJ9AfLkp8QiQcU8AMzI"
        crossorigin="anonymous"></script>

    <!-- <script src="{{ url_for('static', filename='js/lowLag.js') }}"></script>
    <script src="{{ url_for('static', filename='js/soundmanager2.js') }}"></script> -->
    <!-- <script src="//code.jquery.com/jquery-1.8.0.min.js"></script> -->


    <!-- RecordRTC -->
    <!-- <script src="https://www.WebRTC-Experiment.com/RecordRTC.js"></script> -->
</head>

<body>

    Test
    <!-- <button type="button" id="play-button">Start</button>
    <button type="button" id="stop-button">Stop</button> -->

    <button type="button" id="start-record">Let's Chat</button>
    <button type="button" id="stop-record">Stop Chatting</button>

</body>

<script>
    function downsampleBuffer(buffer, input_rate, output_rate) {
        if (input_rate == output_rate) {
            return buffer;
        }
        if (output_rate > input_rate) {
            throw "downsampling rate show be smaller than original sample rate";
        }

        var sampleRateRatio = input_rate / output_rate;
        var newLength = Math.round(buffer.length / sampleRateRatio);
        var result = new Float32Array(newLength);
        var offsetResult = 0;
        var offsetBuffer = 0;
        while (offsetResult < result.length) {
            var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
            // Use average value of skipped samples
            var accum = 0, count = 0;
            for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
                accum += buffer[i];
                count++;
            }
            result[offsetResult] = accum / count;
            // Or you can simply get rid of the skipped samples:
            // result[offsetResult] = buffer[nextOffsetBuffer];
            offsetResult++;
            offsetBuffer = nextOffsetBuffer;
        }
        return result;
    }

    // Setup socket connection
    var socket = io.connect(window.location.protocol + '//' + document.domain + ':' + location.port);
    socket.on('connect', function () {
        console.log("Connected...!", socket.connected)
    });

    const startRecordBtn = document.querySelector('#start-record');
    const stopRecordBtn = document.querySelector('#stop-record');
    // const recordedAudio = document.querySelector('#recorded-audio');

    const mic_sample_rate = 44100; // Hz
    const out_sample_rate = 16000; // Hz
    const blockSize = 2048; // samples



    startRecordBtn.addEventListener('click', function () {
        console.log('Start chatting!');
        socket.emit('system_init', 'welcome');

        navigator.mediaDevices.getUserMedia({ audio: true })
            .then(function (stream) {
                const audioListenCtx = new AudioContext();
                var source = audioListenCtx.createMediaStreamSource(stream);
                var processor = audioListenCtx.createScriptProcessor(blockSize, 1, 1);

                source.connect(processor);
                processor.connect(audioListenCtx.destination);

                processor.onaudioprocess = function (e) {
                    // Get the audio data as an ArrayBuffer
                    var buffer = e.inputBuffer.getChannelData(0);
                    var arrayBuffer = new Float32Array(buffer);

                    var newBuffer = downsampleBuffer(arrayBuffer, mic_sample_rate, out_sample_rate)

                    var encodedData = new Int16Array(newBuffer.length);

                    // Encode the audio data as 16-bit signed integers to save space
                    for (var i = 0; i < newBuffer.length; i++) {
                        encodedData[i] = 32767 * newBuffer[i];
                    }

                    // Send the encoded audio data to the server
                    socket.emit('audio_listen', encodedData.buffer);
                };
            })
            .catch(function (err) {
                console.error(err);
            });
    });

    stopRecordBtn.addEventListener('click', function () {
        
    });

    socket.on('audio_speak', function (audio_data) {
        console.log("Audio data received");
        const audioSpeakCtx = new AudioContext({
            latencyHint: "interactive",
            sampleRate: 44100,
        });

        source = audioSpeakCtx.createBufferSource();
        audioSpeakCtx.decodeAudioData(audio_data,
            (buffer) => {
                source.buffer = buffer;
                source.connect(audioSpeakCtx.destination);
                source.start();
            },
            (err) => console.error(`Error with decoding audio data: ${err.err}`)
        );
    });


</script>

</html>